<!DOCTYPE html>
<html lang="tr">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>API Test Sayfasƒ± - Charger Station</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            min-height: 100vh;
            padding: 20px;
            position: relative;
        }

        /* √úst sol k√∂≈üe logo - UX optimized */
        .top-left-logo {
            position: fixed;
            top: 10px;
            /* Yukarƒ± al */
            left: 25px;
            z-index: 2000;
            width: 140px;
            /* Biraz k√º√ß√ºlt */
            height: auto;
            opacity: 0.95;
            transition: all 0.3s ease;
            background: rgba(255, 255, 255, 0.95);
            padding: 10px 14px;
            /* Daha kompakt padding */
            border-radius: 12px;
            box-shadow: 0 4px 20px rgba(0, 0, 0, 0.25), 0 0 0 1px rgba(255, 255, 255, 0.3);
        }

        .top-left-logo:hover {
            opacity: 1;
            transform: translateY(-2px);
            box-shadow: 0 6px 24px rgba(0, 0, 0, 0.3), 0 0 0 1px rgba(255, 255, 255, 0.4);
        }

        .top-left-logo img {
            width: 100%;
            height: auto;
            display: block;
            filter: drop-shadow(0 2px 4px rgba(0, 0, 0, 0.1));
        }

        /* SVG i√ßindeki ye≈üil rengi daha koyu yap (dƒ±r (daha iyi kontrast i√ßin) */
        .top-left-logo svg {
            filter: brightness(0.9) contrast(1.1);
        }

        .top-left-logo svg .cls-1 {
            fill: #0a6d35 !important;
            /* Daha koyu ye≈üil */
        }

        /* Mobil g√∂r√ºn√ºmde logo boyutu k√º√ß√ºlt */
        @media (max-width: 768px) {
            .top-left-logo {
                width: 120px;
                top: 20px;
                left: 20px;
            }
        }

        /* √áok k√º√ß√ºk ekranlarda logo'yu header'a ta≈üƒ± */
        @media (max-width: 480px) {
            .top-left-logo {
                position: relative;
                top: 0;
                left: 0;
                width: 140px;
                margin: 0 auto 10px;
                display: block;
            }
        }

        .container {
            max-width: 1400px;
            margin: 0 auto;
            background: white;
            border-radius: 15px;
            box-shadow: 0 20px 60px rgba(0, 0, 0, 0.3);
            overflow: hidden;
        }

        .header {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
            padding: 30px;
            text-align: center;
        }

        .header-content {
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 15px;
            margin-bottom: 10px;
            position: relative;
        }

        .header-logo {
            height: 50px;
            width: auto;
            object-fit: contain;
            background: transparent;
        }

        /* Header i√ßindeki logo'yu k√º√ß√ºlt (√ºst sol k√∂≈üe logo varsa) */
        .header-logo {
            opacity: 0.8;
        }

        .header h1 {
            font-size: 2em;
            margin: 0;
        }

        .header p {
            opacity: 0.9;
            font-size: 0.9em;
        }

        /* ESP32 Status Bar */
        .status-bar {
            background: #1a1a1a;
            color: white;
            padding: 10px 15px;
            display: flex;
            align-items: center;
            justify-content: space-between;
            flex-wrap: wrap;
            gap: 8px;
            border-bottom: 3px solid #333;
            position: sticky;
            top: 0;
            z-index: 1000;
            box-shadow: 0 2px 10px rgba(0, 0, 0, 0.3);
        }

        .status-bar-title {
            font-weight: bold;
            font-size: 0.85em;
            color: #888;
            margin-right: 8px;
            white-space: nowrap;
        }

        .status-item {
            display: inline-flex;
            align-items: center;
            gap: 4px;
            padding: 4px 8px;
            border-radius: 4px;
            font-size: 0.8em;
            font-weight: 500;
            background: #2a2a2a;
            border: 1px solid #444;
            transition: all 0.3s ease;
            white-space: nowrap;
            flex-shrink: 0;
        }

        /* STATE item i√ßin dinamik geni≈ülik */
        #statusState {
            min-width: auto;
            width: auto;
        }

        .status-item.changed {
            animation: highlight 0.6s ease;
            box-shadow: 0 0 10px rgba(255, 255, 255, 0.3);
        }

        @keyframes highlight {
            0% {
                transform: scale(1);
            }

            50% {
                transform: scale(1.1);
                background: #444;
            }

            100% {
                transform: scale(1);
            }
        }

        .status-label {
            color: #aaa;
            font-size: 0.75em;
        }

        .status-value {
            font-weight: bold;
            color: white;
            font-size: 0.85em;
        }

        /* STATE renkleri (ESP32 kodundan) - G√∂r√ºn√ºrl√ºk iyile≈ütirmeleri */
        .status-last-update {
            font-size: 0.85em;
            color: #aaa;
            margin-left: auto;
        }

        /* Meter detail grid */
        .meter-detail-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(220px, 1fr));
            gap: 10px;
            margin-top: 10px;
            padding: 0 6px 8px 6px;
        }

        .meter-detail-card {
            background: #223220;
            color: #e8f5e9;
            border: 1px solid #2f4f2f;
            border-radius: 8px;
            padding: 8px 10px;
            box-shadow: inset 0 0 0 1px rgba(255, 255, 255, 0.02);
        }

        .meter-detail-title {
            font-weight: 700;
            font-size: 0.9em;
            margin-bottom: 4px;
        }

        .meter-detail-values {
            font-size: 0.88em;
            line-height: 1.4;
        }

        /* Session info bar */
        .session-bar {
            background: #1f2d38;
            color: #e3f2fd;
            padding: 8px 12px;
            border-top: 1px solid #2e3f4b;
            border-bottom: 1px solid #2e3f4b;
            display: flex;
            align-items: center;
            gap: 10px;
            flex-wrap: wrap;
        }

        .session-item {
            background: #264156;
            border: 1px solid #34556b;
            color: #e3f2fd;
            padding: 6px 10px;
            border-radius: 6px;
            font-size: 0.9em;
            min-width: 150px;
            display: inline-flex;
            align-items: center;
            gap: 6px;
        }

        .session-label {
            color: #b0bec5;
            font-weight: 600;
            font-size: 0.85em;
        }

        .session-value {
            font-weight: 700;
        }

        .mobile-bar {
            background: #0f1c24;
            color: #c8e6c9;
            padding: 10px 14px;
            border-bottom: 1px solid #1d2b33;
            display: flex;
            flex-wrap: wrap;
            gap: 10px;
            align-items: center;
        }

        .mobile-bar .mobile-item {
            background: rgba(255, 255, 255, 0.05);
            border: 1px solid rgba(255, 255, 255, 0.08);
            border-radius: 6px;
            padding: 6px 10px;
            min-width: 160px;
            display: inline-flex;
            align-items: center;
            gap: 6px;
            font-size: 0.9em;
        }

        .mobile-label {
            color: #90caf9;
            font-weight: 600;
            font-size: 0.85em;
        }

        .mobile-value {
            font-weight: 700;
            font-size: 0.95em;
            color: #ffffff;
        }

        .mobile-last-update {
            margin-left: auto;
            color: #9fb3c8;
            font-size: 0.85em;
            white-space: nowrap;
        }

        .mobile-bar.mobile-available {
            background: linear-gradient(90deg, #0f2d23, #0b1b15);
        }

        .mobile-bar.mobile-busy {
            background: linear-gradient(90deg, #2d1b0f, #1b1008);
        }

        .mobile-bar.mobile-fault {
            background: linear-gradient(90deg, #2d0f0f, #1b0808);
        }

        .bar-action-btn {
            margin-left: 15px;
            padding: 8px 20px;
            border: none;
            border-radius: 6px;
            font-weight: bold;
            font-size: 0.9em;
            cursor: pointer;
            transition: all 0.3s ease;
            text-transform: uppercase;
            letter-spacing: 0.5px;
            min-width: 70px;
            height: 36px;
            display: inline-flex;
            align-items: center;
            justify-content: center;
        }

        .bar-start-btn {
            background: #4CAF50;
            color: white;
        }

        .bar-start-btn:hover {
            background: #45a049;
            transform: translateY(-1px);
            box-shadow: 0 4px 8px rgba(76, 175, 80, 0.3);
        }

        .bar-start-btn:active {
            transform: translateY(0);
            box-shadow: 0 2px 4px rgba(76, 175, 80, 0.2);
        }

        .bar-stop-btn {
            background: #f44336;
            color: white;
        }

        .bar-stop-btn:hover {
            background: #da190b;
            transform: translateY(-1px);
            box-shadow: 0 4px 8px rgba(244, 67, 54, 0.3);
        }

        .bar-stop-btn:active {
            transform: translateY(0);
            box-shadow: 0 2px 4px rgba(244, 67, 54, 0.2);
        }

        .status-state-1 {
            background: #e8e8e8;
            border-color: #bbb;
        }

        /* IDLE - A√ßƒ±k Gri */
        .status-state-1 .status-label {
            color: #555;
        }

        /* Koyu gri label */
        .status-state-1 .status-value {
            color: #000;
            font-weight: bold;
        }

        /* Siyah deƒüer */

        .status-state-2 {
            background: rgb(0, 180, 180);
            border-color: rgb(0, 150, 150);
        }

        /* CABLE_DETECT - Turkuaz */
        .status-state-2 .status-label {
            color: rgba(255, 255, 255, 0.9);
        }

        .status-state-2 .status-value {
            color: white;
            font-weight: bold;
        }

        .status-state-3 {
            background: rgb(30, 30, 255);
            border-color: rgb(10, 10, 255);
        }

        /* EV_CONNECTED - Mavi */
        .status-state-3 .status-label {
            color: rgba(255, 255, 255, 0.9);
        }

        .status-state-3 .status-value {
            color: white;
            font-weight: bold;
        }

        .status-state-4 {
            background: rgb(50, 100, 255);
            border-color: rgb(30, 30, 255);
        }

        /* SARJA_HAZIR - A√ßƒ±k Mavi */
        .status-state-4 .status-label {
            color: rgba(255, 255, 255, 0.9);
        }

        .status-state-4 .status-value {
            color: white;
            font-weight: bold;
        }

        .status-state-5 {
            background: #2e7d32;
            border-color: #1b5e20;
        }

        /* SARJ_BASLADI - Koyu Ye≈üil */
        .status-state-5 .status-label {
            color: rgba(255, 255, 255, 0.9);
        }

        .status-state-5 .status-value {
            color: white;
            font-weight: bold;
        }

        .status-state-6 {
            background: rgb(255, 193, 7);
            border-color: rgb(255, 152, 0);
        }

        /* SARJ_DURAKLATILDI - Altƒ±n Sarƒ± */
        .status-state-6 .status-label {
            color: #333;
        }

        .status-state-6 .status-value {
            color: #000;
            font-weight: bold;
        }

        .status-state-7 {
            background: rgb(200, 50, 100);
            border-color: rgb(180, 40, 90);
        }

        /* SARJ_BITIR - Koyu Lila */
        .status-state-7 .status-label {
            color: rgba(255, 255, 255, 0.9);
        }

        .status-state-7 .status-value {
            color: white;
            font-weight: bold;
        }

        .status-state-8 {
            background: #c62828;
            border-color: #b71c1c;
        }

        /* FAULT_HARD - Koyu Kƒ±rmƒ±zƒ± */
        .status-state-8 .status-label {
            color: rgba(255, 255, 255, 0.9);
        }

        .status-state-8 .status-value {
            color: white;
            font-weight: bold;
        }

        .status-indicator {
            width: 6px;
            height: 6px;
            border-radius: 50%;
            background: #4CAF50;
            animation: pulse 2s infinite;
            flex-shrink: 0;
        }

        .status-indicator.offline {
            background: #F44336;
            animation: none;
        }

        @keyframes pulse {

            0%,
            100% {
                opacity: 1;
            }

            50% {
                opacity: 0.5;
            }
        }

        .status-last-update {
            font-size: 0.7em;
            color: #888;
            margin-left: auto;
            white-space: nowrap;
        }

        /* System Metrics Bar */
        .system-metrics-bar {
            background: #2a2a2a;
            color: white;
            padding: 8px 15px;
            display: flex;
            align-items: center;
            justify-content: space-between;
            flex-wrap: wrap;
            gap: 8px;
            border-bottom: 2px solid #444;
            position: sticky;
            top: 0;
            z-index: 999;
            box-shadow: 0 2px 8px rgba(0, 0, 0, 0.2);
        }

        /* Meter Values Bar (low-frequency, safe polling) */
        .meter-values-bar {
            background: #1f2a1f;
            color: white;
            padding: 8px 15px;
            display: flex;
            align-items: center;
            justify-content: space-between;
            flex-wrap: wrap;
            gap: 8px;
            border-bottom: 2px solid #2e7d32;
            position: sticky;
            top: 0;
            z-index: 998;
            box-shadow: 0 2px 8px rgba(0, 0, 0, 0.2);
        }

        .meter-interval-select {
            background: #222;
            color: #fff;
            border: 1px solid #555;
            border-radius: 4px;
            padding: 2px 6px;
            font-size: 0.85em;
        }

        .system-metrics-bar-title {
            font-weight: bold;
            font-size: 0.8em;
            color: #aaa;
            margin-right: 8px;
            white-space: nowrap;
        }

        .metric-item {
            display: inline-flex;
            align-items: center;
            gap: 4px;
            padding: 4px 10px;
            border-radius: 4px;
            font-size: 0.75em;
            font-weight: 500;
            background: #333;
            border: 1px solid #555;
            transition: all 0.3s ease;
            white-space: nowrap;
            flex-shrink: 0;
        }

        /* Metric renkleri: Normal (green), Riskli (yellow), Tehlikeli (red) */
        .metric-normal {
            background: #2e7d32;
            border-color: #1b5e20;
            color: white;
        }

        .metric-warning {
            background: #f57c00;
            border-color: #e65100;
            color: white;
        }

        .metric-danger {
            background: #c62828;
            border-color: #b71c1c;
            color: white;
        }

        .metric-label {
            color: rgba(255, 255, 255, 0.8);
            font-size: 0.85em;
        }

        .metric-value {
            font-weight: bold;
            color: white;
            font-size: 0.9em;
        }

        .content {
            padding: 30px;
        }

        @media (max-width: 768px) {
            .status-bar {
                padding: 8px 10px;
                gap: 6px;
            }

            .status-item {
                padding: 3px 6px;
                font-size: 0.75em;
            }

            .status-bar-title {
                width: 100%;
                margin-bottom: 4px;
            }

            .status-last-update {
                width: 100%;
                margin-left: 0;
                margin-top: 4px;
                text-align: center;
            }

            .bar-action-btn {
                padding: 6px 15px;
                font-size: 0.8em;
                margin-left: 10px;
            }

        }

        .endpoint-group {
            margin-bottom: 30px;
            border: 2px solid #e0e0e0;
            border-radius: 10px;
            padding: 20px;
            background: #f9f9f9;
        }

        .endpoint-group h2 {
            color: #667eea;
            margin-bottom: 15px;
            font-size: 1.3em;
            border-bottom: 2px solid #667eea;
            padding-bottom: 10px;
        }

        .endpoint {
            margin-bottom: 20px;
            padding: 15px;
            background: white;
            border-radius: 8px;
            border-left: 4px solid #667eea;
        }

        .endpoint-header {
            display: flex;
            align-items: center;
            gap: 10px;
            margin-bottom: 10px;
        }

        .method {
            padding: 5px 12px;
            border-radius: 5px;
            font-weight: bold;
            font-size: 0.85em;
            color: white;
        }

        .method.get {
            background: #4CAF50;
        }

        .method.post {
            background: #2196F3;
        }

        .method.put {
            background: #FF9800;
        }

        .method.delete {
            background: #F44336;
        }

        .endpoint-path {
            font-family: 'Courier New', monospace;
            font-size: 1em;
            color: #333;
            font-weight: 500;
        }

        .endpoint-description {
            color: #666;
            font-size: 0.9em;
            margin-bottom: 15px;
        }

        .request-body {
            margin-bottom: 15px;
        }

        .request-body label {
            display: block;
            margin-bottom: 5px;
            color: #333;
            font-weight: 500;
            font-size: 0.9em;
        }

        .request-body input,
        .request-body textarea {
            width: 100%;
            padding: 10px;
            border: 1px solid #ddd;
            border-radius: 5px;
            font-family: 'Courier New', monospace;
            font-size: 0.9em;
        }

        .request-body textarea {
            min-height: 80px;
            resize: vertical;
        }

        .btn {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
            border: none;
            padding: 12px 25px;
            border-radius: 5px;
            cursor: pointer;
            font-size: 1em;
            font-weight: 500;
            transition: transform 0.2s, box-shadow 0.2s;
        }

        .btn:hover {
            transform: translateY(-2px);
            box-shadow: 0 5px 15px rgba(102, 126, 234, 0.4);
        }

        .btn:active {
            transform: translateY(0);
        }

        .response-section {
            margin-top: 20px;
            padding: 15px;
            background: #f5f5f5;
            border-radius: 8px;
            display: none;
        }

        .response-section.show {
            display: block;
        }

        .response-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 10px;
        }

        .response-header h3 {
            color: #333;
            font-size: 1em;
        }

        .status-badge {
            padding: 5px 12px;
            border-radius: 5px;
            font-weight: bold;
            font-size: 0.85em;
        }

        .status-badge.success {
            background: #4CAF50;
            color: white;
        }

        .status-badge.error {
            background: #F44336;
            color: white;
        }

        .status-badge.info {
            background: #2196F3;
            color: white;
        }

        .request-display,
        .response-display {
            background: #2d2d2d;
            color: #f8f8f2;
            padding: 15px;
            border-radius: 5px;
            font-family: 'Courier New', monospace;
            font-size: 0.85em;
            overflow-x: auto;
            white-space: pre-wrap;
            word-wrap: break-word;
            margin-top: 10px;
        }

        .curl-preview {
            background: #f5f5f5;
            border: 1px solid #ddd;
            border-radius: 5px;
            padding: 10px;
            margin-top: 10px;
            margin-bottom: 15px;
        }

        .curl-preview label {
            display: block;
            margin-bottom: 5px;
            color: #333;
            font-weight: 500;
            font-size: 0.9em;
        }

        .curl-preview textarea {
            width: 100%;
            padding: 10px;
            border: 1px solid #ddd;
            border-radius: 5px;
            font-family: 'Courier New', monospace;
            font-size: 0.85em;
            min-height: 80px;
            resize: vertical;
            background: #2d2d2d;
            color: #f8f8f2;
            white-space: pre-wrap;
            word-wrap: break-word;
        }

        .section-title {
            color: #667eea;
            font-size: 0.9em;
            font-weight: 600;
            margin-top: 15px;
            margin-bottom: 5px;
        }

        .info-box {
            background: #e3f2fd;
            border-left: 4px solid #2196F3;
            padding: 15px;
            margin-bottom: 20px;
            border-radius: 5px;
        }

        .info-box p {
            color: #1976d2;
            font-size: 0.9em;
            line-height: 1.6;
        }

        .loading {
            display: inline-block;
            width: 16px;
            height: 16px;
            border: 3px solid rgba(255, 255, 255, .3);
            border-radius: 50%;
            border-top-color: white;
            animation: spin 1s ease-in-out infinite;
            margin-left: 10px;
        }

        @keyframes spin {
            to {
                transform: rotate(360deg);
            }
        }
    </style>
</head>

<body>
    <!-- √úst sol k√∂≈üe logo -->
    <div class="top-left-logo">
        <img src="/static/logo/Orge-RAL6037-Logo.svg" alt="ORGE Logo" style="filter: brightness(0.85) contrast(1.15);">
    </div>

    <div class="container">
        <div class="header">
            <div class="header-content">
                <img src="/static/logo/backrounfree_orge_round.png" alt="ORGE Logo" class="header-logo">
                <h1>ORGE ROUND Commercial v1 Test Page</h1>
            </div>
            <p>for testing use only</p>
        </div>
        <div class="session-bar" id="sessionBar">
            <div class="session-item">
                <span class="session-label">Session:</span>
                <span class="session-value" id="sessionInfo">-</span>
            </div>
            <div class="session-item">
                <span class="session-label">Status:</span>
                <span class="session-value" id="sessionStatus">-</span>
            </div>
            <div class="session-item">
                <span class="session-label">Power:</span>
                <span class="session-value" id="sessionPower">-</span>
            </div>
            <div class="session-item">
                <span class="session-label">Energy:</span>
                <span class="session-value" id="sessionEnergy">-</span>
            </div>
        </div>

        <div class="mobile-bar" id="mobileBar">
            <div class="mobile-item">
                <span class="mobile-label">Availability:</span>
                <span class="mobile-value" id="mobileAvailability">-</span>
            </div>
            <div class="mobile-item">
                <span class="mobile-label">Session:</span>
                <span class="mobile-value" id="mobileSessionSummary">-</span>
            </div>
            <div class="mobile-item">
                <span class="mobile-label">Power:</span>
                <span class="mobile-value" id="mobileRealtimePower">-</span>
            </div>
            <div class="mobile-item">
                <span class="mobile-label">Energy:</span>
                <span class="mobile-value" id="mobileEnergyDelivered">-</span>
            </div>
            <div class="mobile-item">
                <span class="mobile-label">Cost:</span>
                <span class="mobile-value" id="mobileCostEstimate">-</span>
            </div>
            <div class="mobile-item">
                <span class="mobile-label">Trend:</span>
                <span class="mobile-value" id="mobileTrendEnergy">-</span>
            </div>
            <div class="mobile-item">
                <span class="mobile-label">Alerts:</span>
                <span class="mobile-value" id="mobileAlertCount">-</span>
            </div>
            <div class="mobile-last-update" id="mobileSnapshotUpdate">Mobile snapshot: -</div>
        </div>

        <!-- ESP32 Real-Time Status Bar -->
        <div class="status-bar" id="statusBar">
            <div style="display: flex; align-items: center; gap: 8px; flex-wrap: wrap;">
                <span class="status-bar-title">Real-time EV Charging Values:</span>
                <div class="status-item" id="statusIndicator">
                    <span class="status-indicator" id="statusDot"></span>
                    <span class="status-label">Connection</span>
                </div>
                <div class="status-item status-state-1" id="statusState">
                    <span class="status-label">STATE:</span>
                    <span class="status-value" id="stateValue">-</span>
                </div>
                <div class="status-item" id="statusCP">
                    <span class="status-label">CP:</span>
                    <span class="status-value" id="cpValue">-</span>
                </div>
                <div class="status-item" id="statusPP">
                    <span class="status-label">PP:</span>
                    <span class="status-value" id="ppValue">-</span>
                </div>
                <div class="status-item" id="statusRL">
                    <span class="status-label">RL:</span>
                    <span class="status-value" id="rlValue">-</span>
                </div>
                <div class="status-item" id="statusLOCK">
                    <span class="status-label">LOCK:</span>
                    <span class="status-value" id="lockValue">-</span>
                </div>
                <div class="status-item" id="statusMAX">
                    <span class="status-label">MAX:</span>
                    <span class="status-value" id="maxValue">-</span>
                    <span style="font-size: 0.7em; margin-left: 2px;">A</span>
                </div>
                <div class="status-item" id="statusAUTH">
                    <span class="status-label">AUTH:</span>
                    <span class="status-value" id="authValue">-</span>
                </div>
                <div class="status-last-update" id="lastUpdate">Last update: -</div>
            </div>
            <button class="bar-action-btn bar-start-btn" onclick="quickStartCharge()" title="Start charging">Start</button>
        </div>

        <!-- System Metrics Bar -->
        <div class="system-metrics-bar" id="systemMetricsBar">
            <div style="display: flex; align-items: center; gap: 8px; flex-wrap: wrap;">
                <span class="system-metrics-bar-title">System Metrics:</span>
                <div class="metric-item metric-normal" id="metricCPU">
                    <span class="metric-label">CPU:</span>
                    <span class="metric-value" id="cpuValue">-</span>
                </div>
                <div class="metric-item metric-normal" id="metricRAM">
                    <span class="metric-label">RAM:</span>
                    <span class="metric-value" id="ramValue">-</span>
                </div>
                <div class="metric-item metric-normal" id="metricSSD">
                    <span class="metric-label">SSD:</span>
                    <span class="metric-value" id="ssdValue">-</span>
                </div>
                <div class="metric-item metric-normal" id="metricTemp">
                    <span class="metric-label">Temp:</span>
                    <span class="metric-value" id="tempValue">-</span>
                </div>
                <div class="metric-item metric-normal" id="metricNetwork">
                    <span class="metric-label">Network:</span>
                    <span class="metric-value" id="networkValue">-</span>
                </div>
            </div>
            <button class="bar-action-btn bar-stop-btn" onclick="quickStopCharge()" title="Stop charging">Stop</button>
        </div>

        <!-- Meter Values Bar -->
        <div class="meter-values-bar" id="meterValuesBar">
            <div style="display: flex; align-items: center; gap: 8px; flex-wrap: wrap;">
                <span class="system-metrics-bar-title">Meter Values:</span>
                <div class="metric-item metric-normal" id="meterIndicator">
                    <span class="status-indicator offline" id="meterDot"></span>
                    <span class="metric-label">Connection</span>
                </div>
                <div class="metric-item metric-normal" id="meterVoltage">
                    <span class="metric-label">V:</span>
                    <span class="metric-value" id="meterVoltageValue">-</span>
                </div>
                <div class="metric-item metric-normal" id="meterCurrent">
                    <span class="metric-label">A:</span>
                    <span class="metric-value" id="meterCurrentValue">-</span>
                </div>
                <div class="metric-item metric-normal" id="meterPower">
                    <span class="metric-label">kW:</span>
                    <span class="metric-value" id="meterPowerValue">-</span>
                </div>
                <div class="metric-item metric-normal" id="meterEnergy">
                    <span class="metric-label">kWh:</span>
                    <span class="metric-value" id="meterEnergyValue">-</span>
                </div>
                <div class="metric-item metric-normal" id="meterPF">
                    <span class="metric-label">PF:</span>
                    <span class="metric-value" id="meterPFValue">-</span>
                </div>
                <div class="metric-item metric-normal" id="meterFreq">
                    <span class="metric-label">Hz:</span>
                    <span class="metric-value" id="meterFreqValue">-</span>
                </div>
                <div class="metric-item metric-normal" id="meterRefresh">
                    <span class="metric-label">Refresh:</span>
                    <select id="meterIntervalSelect" class="meter-interval-select" onchange="onMeterIntervalChange()">
                        <option value="15000">15 s</option>
                        <option value="30000" selected>30 s</option>
                        <option value="0">Off</option>
                    </select>
                </div>
                <div class="status-last-update" id="meterLastUpdate">Meter: -</div>
            </div>
            <div class="meter-detail-grid">
                <div class="meter-detail-card">
                    <div class="meter-detail-title">Phase Voltage (V)</div>
                    <div class="meter-detail-values" id="meterPhaseVoltage">L1: -, L2: -, L3: -</div>
                </div>
                <div class="meter-detail-card">
                    <div class="meter-detail-title">Phase Current (A)</div>
                    <div class="meter-detail-values" id="meterPhaseCurrent">L1: -, L2: -, L3: -</div>
                </div>
                <div class="meter-detail-card">
                    <div class="meter-detail-title">Phase Power (kW)</div>
                    <div class="meter-detail-values" id="meterPhasePower">L1: -, L2: -, L3: -</div>
                </div>
                <div class="meter-detail-card">
                    <div class="meter-detail-title">Totals</div>
                    <div class="meter-detail-values" id="meterTotals">P: -, E: -</div>
                </div>
            </div>
        </div>

        <div class="content">
            <div class="info-box">
                <p>
                    <strong>‚ÑπÔ∏è Info:</strong> This page is for testing purposes. All requests are sent automatically with the API key. Request and response bodies are shown below.
                </p>
            </div>

            <!-- Health Check -->
            <div class="endpoint-group">
                <h2>System Endpoints</h2>

                <div class="endpoint">
                    <div class="endpoint-header">
                        <span class="method get">GET</span>
                        <span class="endpoint-path">/api/health</span>
                    </div>
                    <div class="endpoint-description">System health check</div>
                    <button class="btn" onclick="testEndpoint('GET', '/api/health', null)">Test</button>
                    <div class="response-section" id="response-/api/health"></div>
                </div>

                <div class="endpoint">
                    <div class="endpoint-header">
                        <span class="method get">GET</span>
                        <span class="endpoint-path">/api/status</span>
                    </div>
                    <div class="endpoint-description">ESP32 status</div>
                    <button class="btn" onclick="testEndpoint('GET', '/api/status', null)">Test</button>
                    <div class="response-section" id="response-/api/status"></div>
                </div>

                <div class="endpoint">
                    <div class="endpoint-header">
                        <span class="method get">GET</span>
                        <span class="endpoint-path">/api/current/available</span>
                    </div>
                    <div class="endpoint-description">Available current range</div>
                    <button class="btn" onclick="testEndpoint('GET', '/api/current/available', null)">Test</button>
                    <div class="response-section" id="response-/api/current/available"></div>
                </div>

                <div class="endpoint">
                    <div class="endpoint-header">
                        <span class="method get">GET</span>
                        <span class="endpoint-path">/api/station/info</span>
                    </div>
                    <div class="endpoint-description">Station info</div>
                    <button class="btn" onclick="testEndpoint('GET', '/api/station/info', null)">Test</button>
                    <div class="response-section" id="response-/api/station/info"></div>
                </div>
            </div>

            <!-- Meter Endpoints -->
            <div class="endpoint-group">
                <h2>Meter Endpoints (Test)</h2>
                <p style="color: #888; font-size: 0.9em; margin-bottom: 15px;">
                    ‚úÖ Meter is active. For safety, use low-frequency reads (15-30 s).
                </p>

                <div class="endpoint">
                    <div class="endpoint-header">
                        <span class="method get">GET</span>
                        <span class="endpoint-path">/api/meter/status</span>
                    </div>
                    <div class="endpoint-description">
                        Meter status and connectivity
                    </div>
                    <button class="btn" onclick="testEndpoint('GET', '/api/meter/status', null)">Test</button>
                    <div class="response-section" id="response-/api/meter/status"></div>
                </div>

                <div class="endpoint">
                    <div class="endpoint-header">
                        <span class="method get">GET</span>
                        <span class="endpoint-path">/api/meter/reading</span>
                    </div>
                    <div class="endpoint-description">
                        Latest meter reading (Voltage, Current, Power, Energy, etc.)
                    </div>
                    <button class="btn" onclick="testEndpoint('GET', '/api/meter/reading', null)">Test</button>
                    <div class="response-section" id="response-/api/meter/reading"></div>
                </div>
            </div>

            <!-- Charge Control -->
            <div class="endpoint-group">
                <h2>Charge Control (Authentication Required)</h2>

                <div class="endpoint">
                    <div class="endpoint-header">
                        <span class="method post">POST</span>
                        <span class="endpoint-path">/api/charge/start</span>
                    </div>
                    <div class="endpoint-description">Start charging</div>
                    <div class="request-body">
                        <label>Request Body (JSON):</label>
                        <textarea id="body-/api/charge/start" placeholder='{"user_id": "your-user-id"}' oninput="updateCurlPreviewDebounced('POST', '/api/charge/start', 'body-/api/charge/start', 'curl-/api/charge/start')">{}</textarea>
                    </div>
                    <div class="curl-preview">
                        <label>üíª cURL Command (Editable):</label>
                        <textarea id="curl-/api/charge/start"></textarea>
                    </div>
                    <button class="btn" onclick="testEndpoint('POST', '/api/charge/start', 'body-/api/charge/start')">Test</button>
                    <div class="response-section" id="response-/api/charge/start"></div>
                </div>

                <div class="endpoint">
                    <div class="endpoint-header">
                        <span class="method post">POST</span>
                        <span class="endpoint-path">/api/charge/stop</span>
                    </div>
                    <div class="endpoint-description">Stop charging</div>
                    <div class="request-body">
                        <label>Request Body (JSON):</label>
                        <textarea id="body-/api/charge/stop" placeholder='{"user_id": "your-user-id"}' oninput="updateCurlPreviewDebounced('POST', '/api/charge/stop', 'body-/api/charge/stop', 'curl-/api/charge/stop')">{}</textarea>
                    </div>
                    <div class="curl-preview">
                        <label>üíª cURL Command (Editable):</label>
                        <textarea id="curl-/api/charge/stop"></textarea>
                    </div>
                    <button class="btn" onclick="testEndpoint('POST', '/api/charge/stop', 'body-/api/charge/stop')">Test</button>
                    <div class="response-section" id="response-/api/charge/stop"></div>
                </div>
            </div>

            <!-- Current Control -->
            <div class="endpoint-group">
                <h2>Current Control (Authentication Required)</h2>

                <div class="endpoint">
                    <div class="endpoint-header">
                        <span class="method post">POST</span>
                        <span class="endpoint-path">/api/maxcurrent</span>
                    </div>
                    <div class="endpoint-description">Set maximum current (6-32A)</div>
                    <div class="request-body">
                        <label>Amperage:</label>
                        <input type="number" id="body-/api/maxcurrent" placeholder="16" value="16" min="6" max="32" oninput="updateCurlPreviewDebounced('POST', '/api/maxcurrent', 'body-/api/maxcurrent', 'curl-/api/maxcurrent', true)">
                    </div>
                    <div class="curl-preview">
                        <label>üíª cURL Command (Editable):</label>
                        <textarea id="curl-/api/maxcurrent"></textarea>
                    </div>
                    <button class="btn" id="btn-maxcurrent" onclick="testEndpoint('POST', '/api/maxcurrent', 'body-/api/maxcurrent', true, event)">Test</button>
                    <div class="response-section" id="response-/api/maxcurrent"></div>
                </div>
            </div>

            <!-- Session Management -->
            <div class="endpoint-group">
                <h2>Session Management</h2>

                <div class="endpoint">
                    <div class="endpoint-header">
                        <span class="method get">GET</span>
                        <span class="endpoint-path">/api/sessions/current</span>
                    </div>
                    <div class="endpoint-description">
                        <strong>‚≠ê Active Session Lookup</strong><br>
                        Fetches the active session without parameters. Shows Session ID, User ID and all session details.
                    </div>
                    <div class="curl-preview">
                        <label>üíª cURL Command (Editable):</label>
                        <textarea id="curl-/api/sessions/current"></textarea>
                    </div>
                    <button class="btn" onclick="testEndpoint('GET', '/api/sessions/current', null)">Test</button>
                    <div class="response-section" id="response-/api/sessions/current"></div>
                </div>

                <div class="endpoint">
                    <div class="endpoint-header">
                        <span class="method get">GET</span>
                        <span class="endpoint-path">/api/sessions/{session_id}</span>
                    </div>
                    <div class="endpoint-description">Fetch a specific session</div>
                    <div class="request-body">
                        <label>Session ID:</label>
                        <input type="text" id="param-/api/sessions/{session_id}" placeholder="session-uuid-here" value="" oninput="updateCurlPreviewForPathParam('GET', '/api/sessions/{session_id}', 'param-/api/sessions/{session_id}', 'curl-/api/sessions/{session_id}')">
                    </div>
                    <div class="curl-preview">
                        <label>üíª cURL Command (Editable):</label>
                        <textarea id="curl-/api/sessions/{session_id}"></textarea>
                    </div>
                    <button class="btn" onclick="testEndpointWithPathParam('GET', '/api/sessions/{session_id}', 'param-/api/sessions/{session_id}')">Test</button>
                    <div class="response-section" id="response-/api/sessions/{session_id}"></div>
                </div>

                <div class="endpoint">
                    <div class="endpoint-header">
                        <span class="method get">GET</span>
                        <span class="endpoint-path">/api/sessions/users/{user_id}/current</span>
                    </div>
                    <div class="endpoint-description">
                        <strong>‚≠ê User Active Session</strong><br>
                        Fetches the active session for a specific user. Returns null if none.
                    </div>
                    <div class="request-body">
                        <label>User ID:</label>
                        <input type="text" id="param-/api/sessions/users/{user_id}/current" placeholder="user-id-here" value="" oninput="updateCurlPreviewForPathParam('GET', '/api/sessions/users/{user_id}/current', 'param-/api/sessions/users/{user_id}/current', 'curl-/api/sessions/users/{user_id}/current')">
                    </div>
                    <div class="curl-preview">
                        <label>üíª cURL Command (Editable):</label>
                        <textarea id="curl-/api/sessions/users/{user_id}/current"></textarea>
                    </div>
                    <button class="btn" onclick="testEndpointWithPathParam('GET', '/api/sessions/users/{user_id}/current', 'param-/api/sessions/users/{user_id}/current')">Test</button>
                    <div class="response-section" id="response-/api/sessions/users/{user_id}/current"></div>
                </div>

                <div class="endpoint">
                    <div class="endpoint-header">
                        <span class="method get">GET</span>
                        <span class="endpoint-path">/api/sessions/users/{user_id}/sessions</span>
                    </div>
                    <div class="endpoint-description">
                        <strong>üìú User Session History</strong><br>
                        Fetches past sessions for a user (excluding ACTIVE; includes completed/cancelled/faulted).
                    </div>
                    <div class="request-body">
                        <label>User ID:</label>
                        <input type="text" id="param-/api/sessions/users/{user_id}/sessions" placeholder="user-id-here" value="" oninput="updateCurlPreviewForPathParam('GET', '/api/sessions/users/{user_id}/sessions', 'param-/api/sessions/users/{user_id}/sessions', 'curl-/api/sessions/users/{user_id}/sessions')">
                    </div>
                    <div class="curl-preview">
                        <label>üíª cURL Command (Editable):</label>
                        <textarea id="curl-/api/sessions/users/{user_id}/sessions"></textarea>
                    </div>
                    <button class="btn" onclick="testEndpointWithPathParam('GET', '/api/sessions/users/{user_id}/sessions', 'param-/api/sessions/users/{user_id}/sessions')">Test</button>
                    <div class="response-section" id="response-/api/sessions/users/{user_id}/sessions"></div>
                </div>
            </div>

            <!-- Mobile Experience -->
            <div class="endpoint-group">
                <h2>Mobile Experience API</h2>
                <p style="color: #888; font-size: 0.9em; margin-bottom: 15px;">
                    Mobil uygulamanƒ±n kullandƒ±ƒüƒ± birle≈üik endpoint'ler. ≈ûarj durumu, trend verileri ve alert listeleri tek noktadan √ßekilebilir.
                </p>

                <div class="endpoint">
                    <div class="endpoint-header">
                        <span class="method get">GET</span>
                        <span class="endpoint-path">/api/mobile/charging/current</span>
                    </div>
                    <div class="endpoint-description">
                        Aktif cihaz, session, √∂l√ß√ºmler ve alert verilerini tek payload i√ßinde d√∂nd√ºr√ºr.
                    </div>
                    <div class="curl-preview">
                        <label>üíª cURL Command (Editable):</label>
                        <textarea id="curl-/api/mobile/charging/current"></textarea>
                    </div>
                    <button class="btn" onclick="testEndpoint('GET', '/api/mobile/charging/current', null, false, event, 'response-/api/mobile/charging/current')">Test</button>
                    <div class="response-section" id="response-/api/mobile/charging/current"></div>
                </div>

                <div class="endpoint">
                    <div class="endpoint-header">
                        <span class="method get">GET</span>
                        <span class="endpoint-path">/api/mobile/charging/sessions</span>
                    </div>
                    <div class="endpoint-description">
                        Ge√ßmi≈ü ≈üarj oturumlarƒ±nƒ± limit, tarih, kullanƒ±cƒ± ve durum filtresi ile d√∂nd√ºr√ºr.
                    </div>
                    <div class="request-body">
                        <label>Query Parameters:</label>
                        <div class="request-body" style="display: grid; grid-template-columns: repeat(auto-fit, minmax(160px, 1fr)); gap: 10px;">
                            <div>
                                <small>Limit</small>
                                <input type="number" id="mobileSessionsLimit" value="20" min="1" max="200" oninput="updateMobileSessionsCurl()">
                            </div>
                            <div>
                                <small>Status</small>
                                <select id="mobileSessionsStatus" onchange="updateMobileSessionsCurl()">
                                    <option value="">All</option>
                                    <option value="ACTIVE">ACTIVE</option>
                                    <option value="COMPLETED">COMPLETED</option>
                                    <option value="CANCELLED">CANCELLED</option>
                                    <option value="FAULTED">FAULTED</option>
                                </select>
                            </div>
                            <div>
                                <small>User ID</small>
                                <input type="text" id="mobileSessionsUserId" placeholder="user-id" oninput="updateMobileSessionsCurl()">
                            </div>
                            <div>
                                <small>From (UTC)</small>
                                <input type="datetime-local" id="mobileSessionsFrom" oninput="updateMobileSessionsCurl()">
                            </div>
                            <div>
                                <small>To (UTC)</small>
                                <input type="datetime-local" id="mobileSessionsTo" oninput="updateMobileSessionsCurl()">
                            </div>
                        </div>
                    </div>
                    <div class="curl-preview">
                        <label>üíª cURL Command (Editable):</label>
                        <textarea id="curl-/api/mobile/charging/sessions"></textarea>
                    </div>
                    <button class="btn" onclick="testMobileSessionsList(event)">Test</button>
                    <div class="response-section" id="response-/api/mobile/charging/sessions"></div>
                </div>

                <div class="endpoint">
                    <div class="endpoint-header">
                        <span class="method get">GET</span>
                        <span class="endpoint-path">/api/mobile/charging/sessions/{session_id}</span>
                    </div>
                    <div class="endpoint-description">
                        Belirli bir oturum i√ßin enerji, g√º√ß ve maliyet √∂zetlerini d√∂nd√ºr√ºr.
                    </div>
                    <div class="request-body">
                        <label>Session ID:</label>
                        <input type="text" id="param-/api/mobile/charging/sessions/{session_id}" placeholder="session-uuid" value="" oninput="updateCurlPreviewForPathParam('GET', '/api/mobile/charging/sessions/{session_id}', 'param-/api/mobile/charging/sessions/{session_id}', 'curl-/api/mobile/charging/sessions/{session_id}')">
                    </div>
                    <div class="curl-preview">
                        <label>üíª cURL Command (Editable):</label>
                        <textarea id="curl-/api/mobile/charging/sessions/{session_id}"></textarea>
                    </div>
                    <button class="btn" onclick="testEndpointWithPathParam('GET', '/api/mobile/charging/sessions/{session_id}', 'param-/api/mobile/charging/sessions/{session_id}')">Test</button>
                    <div class="response-section" id="response-/api/mobile/charging/sessions/{session_id}"></div>
                </div>
            </div>
        </div>
    </div>

    <script>
        // API base URL - Ngrok veya local
        const API_BASE_URL = window.location.origin;
        let cachedApiKey = null;

        // Debounce timer for curl preview updates
        let curlPreviewTimeouts = {};

        // ESP32 Status Tracking
        let lastStatusData = {};
        let lastSystemMetrics = {};
        let statusUpdateInterval = null;
        let systemMetricsInterval = null;
        let sessionUpdateInterval = null;
        let statusErrorCount = 0; // Ardƒ±≈üƒ±k hata sayacƒ±

        // Meter Values Tracking (low frequency, no overlap)
        let lastMeterData = {};
        let meterUpdateInterval = null;
        let meterPollInProgress = false;
        let meterErrorCount = 0;
        let lastMeterEnergyKwh = null;
        let sessionEnergyBaselineKwh = null;
        let currentSessionId = null;
        let mobileSnapshotInterval = null;

        // STATE a√ßƒ±klamalarƒ±
        const STATE_MEANINGS = {
            1: 'IDLE',
            2: 'CABLE DETECT',
            3: 'EV CONNECTED',
            4: 'READY TO CHARGE',
            5: 'EV CHARGING',
            6: 'SUSPENDED EV',
            7: 'FINISHING',
            8: 'FAULT_HARD'
        };

        // Initialize curl previews and status bar on page load
        // Quick charge start/stop functions
        async function quickStartCharge() {
            try {
                const response = await fetch(`${API_BASE_URL}/api/test/key`);
                const keyData = await response.json();
                const apiKey = keyData.api_key;
                const userId = keyData.user_id || null;

                const requestBody = userId ? {
                    user_id: userId
                } : {};

                const chargeResponse = await fetch(`${API_BASE_URL}/api/charge/start`, {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json',
                        'X-API-Key': apiKey
                    },
                    body: JSON.stringify(requestBody)
                });

                const result = await chargeResponse.json();
                if (result.success) {
                    alert('‚úÖ Charge started!');
                    // Status'u g√ºncelle
                    await updateStatus();
                } else {
                    alert('‚ùå Charge could not start: ' + (result.message || 'Unknown error'));
                }
            } catch (error) {
                alert('‚ùå Error: ' + error.message);
            }
        }

        async function quickStopCharge() {
            try {
                const response = await fetch(`${API_BASE_URL}/api/test/key`);
                const keyData = await response.json();
                const apiKey = keyData.api_key;
                const userId = keyData.user_id || null;

                const requestBody = userId ? {
                    user_id: userId
                } : {};

                const chargeResponse = await fetch(`${API_BASE_URL}/api/charge/stop`, {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json',
                        'X-API-Key': apiKey
                    },
                    body: JSON.stringify(requestBody)
                });

                const result = await chargeResponse.json();
                if (result.success) {
                    alert('‚úÖ Charge stopped!');
                    // Status'u g√ºncelle
                    await updateStatus();
                } else {
                    alert('‚ùå Charge stop failed: ' + (result.message || 'Unknown error'));
                }
            } catch (error) {
                alert('‚ùå Error: ' + error.message);
            }
        }

        document.addEventListener('DOMContentLoaded', async () => {
            cachedApiKey = await getApiKey();

            // Load default values for input fields
            await loadDefaultValues();

            updateCurlPreview('POST', '/api/charge/start', 'body-/api/charge/start', 'curl-/api/charge/start');
            updateCurlPreview('POST', '/api/charge/stop', 'body-/api/charge/stop', 'curl-/api/charge/stop');
            updateCurlPreview('POST', '/api/maxcurrent', 'body-/api/maxcurrent', 'curl-/api/maxcurrent', true);
            updateCurlPreview('GET', '/api/sessions/current', null, 'curl-/api/sessions/current');
            updateCurlPreviewForPathParam('GET', '/api/sessions/{session_id}', 'param-/api/sessions/{session_id}', 'curl-/api/sessions/{session_id}');
            updateCurlPreviewForPathParam('GET', '/api/sessions/users/{user_id}/current', 'param-/api/sessions/users/{user_id}/current', 'curl-/api/sessions/users/{user_id}/current');
            updateCurlPreviewForPathParam('GET', '/api/sessions/users/{user_id}/sessions', 'param-/api/sessions/users/{user_id}/sessions', 'curl-/api/sessions/users/{user_id}/sessions');
            updateCurlPreview('GET', '/api/meter/status', null, 'curl-/api/meter/status');
            updateCurlPreview('GET', '/api/meter/reading', null, 'curl-/api/meter/reading');
            updateCurlPreview('GET', '/api/mobile/charging/current', null, 'curl-/api/mobile/charging/current');
            updateCurlPreviewForPathParam('GET', '/api/mobile/charging/sessions/{session_id}', 'param-/api/mobile/charging/sessions/{session_id}', 'curl-/api/mobile/charging/sessions/{session_id}');
            updateMobileSessionsCurl();

            // Start ESP32 status polling
            startStatusPolling();
            startSessionPolling();
            startMobileSnapshotPolling();
        });

        // Load default values for input fields
        async function loadDefaultValues() {
            try {
                // Get User ID from /api/test/key endpoint
                const keyResponse = await fetch(`${API_BASE_URL}/api/test/key`);
                if (keyResponse.ok) {
                    const keyData = await keyResponse.json();
                    const userId = keyData.user_id;

                    if (userId) {
                        // Set User ID in all user_id input fields
                        const userIdInputs = [
                            'param-/api/sessions/users/{user_id}/current',
                            'param-/api/sessions/users/{user_id}/sessions',
                            'mobileSessionsUserId'
                        ];

                        userIdInputs.forEach(inputId => {
                            const input = document.getElementById(inputId);
                            if (input && !input.value) {
                                input.value = userId;
                                // Trigger oninput event to update curl preview
                                input.dispatchEvent(new Event('input'));
                            }
                        });

                        // Set User ID in charge start/stop body fields
                        const chargeStartBody = document.getElementById('body-/api/charge/start');
                        const chargeStopBody = document.getElementById('body-/api/charge/stop');

                        if (chargeStartBody) {
                            try {
                                const currentValue = chargeStartBody.value.trim();
                                let bodyObj = {};
                                if (currentValue) {
                                    bodyObj = JSON.parse(currentValue);
                                }
                                bodyObj.user_id = userId;
                                chargeStartBody.value = JSON.stringify(bodyObj, null, 2);
                                chargeStartBody.dispatchEvent(new Event('input'));
                            } catch (e) {
                                // If parsing fails, set default with user_id
                                chargeStartBody.value = JSON.stringify({
                                    user_id: userId
                                }, null, 2);
                                chargeStartBody.dispatchEvent(new Event('input'));
                            }
                        }

                        if (chargeStopBody) {
                            try {
                                const currentValue = chargeStopBody.value.trim();
                                let bodyObj = {};
                                if (currentValue) {
                                    bodyObj = JSON.parse(currentValue);
                                }
                                bodyObj.user_id = userId;
                                chargeStopBody.value = JSON.stringify(bodyObj, null, 2);
                                chargeStopBody.dispatchEvent(new Event('input'));
                            } catch (e) {
                                // If parsing fails, set default with user_id
                                chargeStopBody.value = JSON.stringify({
                                    user_id: userId
                                }, null, 2);
                                chargeStopBody.dispatchEvent(new Event('input'));
                            }
                        }
                    }
                }

                // Get current session ID from /api/sessions/current endpoint
                const sessionResponse = await fetch(`${API_BASE_URL}/api/sessions/current`);
                if (sessionResponse.ok) {
                    const sessionData = await sessionResponse.json();
                    const session = sessionData.session;

                    if (session && session.session_id) {
                        // Set Session ID in session_id input field
                        const sessionIdInput = document.getElementById('param-/api/sessions/{session_id}');
                        if (sessionIdInput && !sessionIdInput.value) {
                            sessionIdInput.value = session.session_id;
                            // Trigger oninput event to update curl preview
                            sessionIdInput.dispatchEvent(new Event('input'));
                        }

                        const mobileSessionInput = document.getElementById('param-/api/mobile/charging/sessions/{session_id}');
                        if (mobileSessionInput && !mobileSessionInput.value) {
                            mobileSessionInput.value = session.session_id;
                            mobileSessionInput.dispatchEvent(new Event('input'));
                        }
                    }
                }
            } catch (error) {
                console.error('Error loading default values:', error);
                // Non-critical error, continue without defaults
            }
        }

        async function startStatusPolling() {
            // ƒ∞lk g√ºncelleme
            await updateESP32Status();

            // Her 10 saniyede bir g√ºncelle (rate limit + stabilite i√ßin daha g√ºvenli)
            statusUpdateInterval = setInterval(updateESP32Status, 10000);

            // Sistem metriklerini g√ºncelle (her 5 saniyede bir)
            systemMetricsInterval = setInterval(updateSystemMetrics, 5000);
            updateSystemMetrics(); // ƒ∞lk g√ºncelleme

            // Meter deƒüerlerini d√º≈ü√ºk frekansta g√ºncelle (varsayƒ±lan 30 sn)
            startMeterPolling();
        }

        async function updateESP32Status() {
            try {
                const response = await fetch(`${API_BASE_URL}/api/status`);
                // Rate limit (HTTP 429) durumunda verileri temizleme; sadece uyarƒ± g√∂ster
                if (response.status === 429) {
                    statusErrorCount++;
                    document.getElementById('statusDot').classList.add('offline');
                    document.getElementById('lastUpdate').textContent =
                        `Rate limit (HTTP 429) - values retained (${statusErrorCount})`;
                    return;
                }
                if (!response.ok) {
                    throw new Error(`HTTP ${response.status}`);
                }

                const data = await response.json();
                if (data.success && data.data) {
                    updateStatusBar(data.data);
                    document.getElementById('statusDot').classList.remove('offline');
                    // Ba≈üarƒ±lƒ± g√ºncelleme - hata sayacƒ±nƒ± sƒ±fƒ±rla
                    statusErrorCount = 0;
                } else {
                    throw new Error('Invalid response format');
                }
            } catch (error) {
                console.error('Status update error:', error);
                statusErrorCount++;

                // Hata: offline g√∂ster ama verileri koru (data cleared YOK)
                document.getElementById('statusDot').classList.add('offline');
                document.getElementById('lastUpdate').textContent =
                    `Connection error - values retained (${statusErrorCount})`;
            }
        }

        // Status bar'ƒ± temizle (hata durumunda)
        function clearStatusBar() {
            document.getElementById('stateValue').textContent = '-';
            document.getElementById('cpValue').textContent = '-';
            document.getElementById('ppValue').textContent = '-';
            document.getElementById('rlValue').textContent = '-';
            document.getElementById('lockValue').textContent = '-';
            document.getElementById('maxValue').textContent = '-';
            document.getElementById('authValue').textContent = '-';
            // STATE i√ßin varsayƒ±lan renk sƒ±nƒ±fƒ±nƒ± geri y√ºkle
            const stateContainer = document.getElementById('statusState');
            stateContainer.className = 'status-item status-state-1';
            // Son durum verilerini temizle
            lastStatusData = {};
        }

        async function updateStatus() {
            // Status'u fetch edip updateStatusBar'a g√∂nder
            try {
                const response = await fetch(`${API_BASE_URL}/api/status`, {
                    headers: {
                        'X-API-Key': await getApiKey()
                    }
                });
                const result = await response.json();
                if (result.success && result.data) {
                    updateStatusBar(result.data);
                }
            } catch (error) {
                console.error('Status update error:', error);
            }
        }

        function updateStatusBar(data) {
            const now = new Date();
            const timeStr = now.toLocaleTimeString('tr-TR');

            // Son g√ºncelleme zamanƒ±
            document.getElementById('lastUpdate').textContent = `Last update: ${timeStr}`;

            // STATE g√ºncelleme (renk deƒüi≈üimi ile) - Format: "STATE: 1-IDLE"
            const stateText = `${data.STATE}-${STATE_MEANINGS[data.STATE] || 'UNKNOWN'}`;
            updateStatusItem('stateValue', data.STATE, stateText, 'statusState', `status-state-${data.STATE}`);
            window.lastStatusState = data.STATE;

            // Diƒüer deƒüerler
            updateStatusItem('cpValue', data.CP, data.CP);
            updateStatusItem('ppValue', data.PP, data.PP);
            updateStatusItem('rlValue', data.RL, data.RL);
            updateStatusItem('lockValue', data.LOCK, data.LOCK);
            updateStatusItem('maxValue', data.MAX, data.MAX);
            updateStatusItem('authValue', data.AUTH, data.AUTH);
        }

        function updateStatusItem(elementId, newValue, displayValue, containerId = null, stateClass = null) {
            const element = document.getElementById(elementId);
            const container = containerId ? document.getElementById(containerId) : element.parentElement;

            if (!element) return;

            const oldValue = lastStatusData[elementId];
            const hasChanged = oldValue !== undefined && oldValue !== newValue;

            // Deƒüeri g√ºncelle
            element.textContent = displayValue;
            lastStatusData[elementId] = newValue;

            // STATE i√ßin renk sƒ±nƒ±fƒ±nƒ± g√ºncelle
            if (stateClass && container) {
                // Eski state sƒ±nƒ±flarƒ±nƒ± kaldƒ±r
                container.className = container.className.replace(/status-state-\d+/g, '');
                // Yeni state sƒ±nƒ±fƒ±nƒ± ekle
                container.classList.add('status-item', stateClass);
            }

            // Deƒüi≈üiklik varsa highlight animasyonu
            if (hasChanged && container) {
                container.classList.add('changed');
                setTimeout(() => {
                    container.classList.remove('changed');
                }, 600);
            }
        }

        // Sistem metriklerini g√ºncelle
        async function updateSystemMetrics() {
            try {
                const response = await fetch(`${API_BASE_URL}/api/health`);
                if (!response.ok) {
                    throw new Error(`HTTP ${response.status}`);
                }

                const data = await response.json();
                if (data.success && data.data) {
                    updateSystemMetricsBar(data.data);
                } else {
                    throw new Error('Invalid response format');
                }
            } catch (error) {
                console.error('System metrics update error:', error);
                // Hata durumunda metrikleri temizle
                clearSystemMetrics();
            }
        }

        function updateSystemMetricsBar(data) {
            // CPU g√ºncelleme
            const cpuPercent = data.cpu_percent !== null && data.cpu_percent !== undefined ?
                data.cpu_percent.toFixed(1) :
                (data.system_cpu_percent !== null && data.system_cpu_percent !== undefined ?
                    data.system_cpu_percent.toFixed(1) :
                    null);

            if (cpuPercent !== null) {
                updateMetric('cpuValue', cpuPercent + '%', 'metricCPU', cpuPercent, 0, 50, 80);
            } else {
                document.getElementById('cpuValue').textContent = 'N/A';
                document.getElementById('metricCPU').className = 'metric-item metric-normal';
            }

            // RAM g√ºncelleme
            const ramPercent = data.memory_percent !== null && data.memory_percent !== undefined ?
                data.memory_percent :
                (data.system_memory_percent !== null && data.system_memory_percent !== undefined ?
                    data.system_memory_percent :
                    null);

            const ramUsed = data.memory_mb !== null && data.memory_mb !== undefined ?
                data.memory_mb.toFixed(1) :
                null;

            const ramTotal = data.system_memory_total_mb !== null && data.system_memory_total_mb !== undefined ?
                data.system_memory_total_mb.toFixed(0) :
                null;

            if (ramPercent !== null) {
                let ramDisplay = ramPercent.toFixed(1) + '%';
                if (ramUsed !== null && ramTotal !== null) {
                    ramDisplay = `${ramUsed}MB/${ramTotal}MB (${ramPercent.toFixed(1)}%)`;
                }
                updateMetric('ramValue', ramDisplay, 'metricRAM', ramPercent, 0, 70, 85);
            } else {
                document.getElementById('ramValue').textContent = 'N/A';
                document.getElementById('metricRAM').className = 'metric-item metric-normal';
            }

            // SSD g√ºncelleme
            const ssdPercent = (data.disk_percent !== null && data.disk_percent !== undefined) ?
                data.disk_percent :
                null;

            const ssdUsed = (data.disk_used_gb !== null && data.disk_used_gb !== undefined) ?
                parseFloat(data.disk_used_gb).toFixed(1) :
                null;

            const ssdTotal = (data.disk_total_gb !== null && data.disk_total_gb !== undefined) ?
                parseFloat(data.disk_total_gb).toFixed(1) :
                null;

            if (ssdPercent !== null && !isNaN(ssdPercent)) {
                let ssdDisplay = ssdPercent.toFixed(1) + '%';
                if (ssdUsed !== null && ssdTotal !== null) {
                    ssdDisplay = `${ssdUsed}GB/${ssdTotal}GB (${ssdPercent.toFixed(1)}%)`;
                }
                updateMetric('ssdValue', ssdDisplay, 'metricSSD', ssdPercent, 0, 80, 90);
            } else {
                document.getElementById('ssdValue').textContent = 'N/A';
                document.getElementById('metricSSD').className = 'metric-item metric-normal';
            }

            // Temperature g√ºncelleme
            const tempCelsius = data.cpu_temperature_celsius !== null && data.cpu_temperature_celsius !== undefined ?
                data.cpu_temperature_celsius :
                null;

            if (tempCelsius !== null) {
                const tempDisplay = tempCelsius.toFixed(1) + '¬∞C';
                updateMetric('tempValue', tempDisplay, 'metricTemp', tempCelsius, 0, 70, 80);
            } else {
                document.getElementById('tempValue').textContent = 'N/A';
                document.getElementById('metricTemp').className = 'metric-item metric-normal';
            }

            // Network bilgileri g√ºncelleme (SSID, IP ve sinyal)
            const networkIP = (data.network_ip !== null && data.network_ip !== undefined && data.network_ip !== '') ?
                data.network_ip :
                null;

            const networkSSID = (data.network_ssid !== null && data.network_ssid !== undefined && data.network_ssid !== '') ?
                data.network_ssid :
                null;

            const networkSignal = (data.network_signal !== null && data.network_signal !== undefined && !Number.isNaN(Number(data.network_signal))) ?
                Number(data.network_signal) :
                null;

            if (networkIP || networkSSID || networkSignal !== null) {
                let networkDisplay = '';
                if (networkSSID) {
                    networkDisplay = networkSSID;
                }
                if (networkSignal !== null) {
                    networkDisplay += networkDisplay ? ` (${networkSignal}%)` : `${networkSignal}%`;
                }
                if (networkIP) {
                    networkDisplay += networkDisplay ? ` / ${networkIP}` : networkIP;
                }
                document.getElementById('networkValue').textContent = networkDisplay || 'N/A';
                // Sinyal i√ßin renk kodlamasƒ± (>=70 iyi, >=50 orta, altƒ± d√º≈ü√ºk)
                if (networkSignal !== null) {
                    updateMetric('networkValue', networkDisplay, 'metricNetwork', networkSignal, 0, 50, 70);
                } else {
                    document.getElementById('metricNetwork').className = 'metric-item metric-normal';
                }
            } else {
                document.getElementById('networkValue').textContent = 'N/A';
                document.getElementById('metricNetwork').className = 'metric-item metric-normal';
            }
        }

        function updateMetric(elementId, displayValue, containerId, value, normalThreshold, warningThreshold, dangerThreshold) {
            const element = document.getElementById(elementId);
            const container = document.getElementById(containerId);

            if (!element || !container) return;

            const oldValue = lastSystemMetrics[elementId];
            const hasChanged = oldValue !== undefined && oldValue !== displayValue;

            // Deƒüeri g√ºncelle
            element.textContent = displayValue;
            lastSystemMetrics[elementId] = displayValue;

            // Renk kodlamasƒ±: Normal (green), Riskli (yellow), Tehlikeli (red)
            let metricClass = 'metric-normal';
            if (value >= dangerThreshold) {
                metricClass = 'metric-danger';
            } else if (value >= warningThreshold) {
                metricClass = 'metric-warning';
            }

            // Renk sƒ±nƒ±fƒ±nƒ± g√ºncelle
            container.className = `metric-item ${metricClass}`;

            // Deƒüi≈üiklik varsa highlight animasyonu
            if (hasChanged) {
                container.classList.add('changed');
                setTimeout(() => {
                    container.classList.remove('changed');
                }, 600);
            }
        }

        function clearSystemMetrics() {
            document.getElementById('cpuValue').textContent = '-';
            document.getElementById('ramValue').textContent = '-';
            document.getElementById('ssdValue').textContent = '-';
            document.getElementById('tempValue').textContent = '-';
            document.getElementById('networkValue').textContent = '-';

            // Varsayƒ±lan renkleri geri y√ºkle
            document.getElementById('metricCPU').className = 'metric-item metric-normal';
            document.getElementById('metricRAM').className = 'metric-item metric-normal';
            document.getElementById('metricSSD').className = 'metric-item metric-normal';
            document.getElementById('metricTemp').className = 'metric-item metric-normal';
            document.getElementById('metricNetwork').className = 'metric-item metric-normal';

            lastSystemMetrics = {};
        }

        // Meter bar helper'larƒ±
        function clearMeterValues() {
            document.getElementById('meterVoltageValue').textContent = '-';
            document.getElementById('meterCurrentValue').textContent = '-';
            document.getElementById('meterPowerValue').textContent = '-';
            document.getElementById('meterEnergyValue').textContent = '-';
            lastMeterData = {};
        }

        function formatMeterNumber(value, digits) {
            if (value === null || value === undefined) return '-';
            const num = Number(value);
            if (Number.isNaN(num)) return '-';
            return num.toFixed(digits);
        }

        function updateMeterItem(elementId, newValue, displayValue, containerId) {
            const element = document.getElementById(elementId);
            const container = containerId ? document.getElementById(containerId) : null;
            if (!element) return;

            const oldValue = lastMeterData[elementId];
            const hasChanged = oldValue !== undefined && oldValue !== newValue;

            element.textContent = displayValue;
            lastMeterData[elementId] = newValue;

            if (hasChanged && container) {
                container.classList.add('changed');
                setTimeout(() => container.classList.remove('changed'), 600);
            }
        }

        function setMetricState(containerId, state = 'normal') {
            const container = document.getElementById(containerId);
            if (!container) return;
            container.classList.remove('metric-normal', 'metric-warning', 'metric-danger');
            if (state === 'warning') {
                container.classList.add('metric-warning');
            } else if (state === 'danger') {
                container.classList.add('metric-danger');
            } else {
                container.classList.add('metric-normal');
            }
        }

        function setMeterPollingInterval(intervalMs) {
            if (meterUpdateInterval) {
                clearInterval(meterUpdateInterval);
                meterUpdateInterval = null;
            }

            if (!intervalMs || intervalMs <= 0) {
                document.getElementById('meterLastUpdate').textContent = 'Meter: disabled';
                return;
            }

            meterUpdateInterval = setInterval(updateMeterValues, intervalMs);
        }

        function onMeterIntervalChange() {
            try {
                const select = document.getElementById('meterIntervalSelect');
                const intervalMs = select ? parseInt(select.value, 10) : 30000;
                setMeterPollingInterval(intervalMs);
                updateMeterValues();
            } catch (error) {
                console.error('Meter interval change error:', error);
            }
        }

        async function startMeterPolling() {
            // ƒ∞lk okuma
            await updateMeterValues();
            // Periyodik okuma (default: select deƒüeri)
            const select = document.getElementById('meterIntervalSelect');
            const intervalMs = select ? parseInt(select.value, 10) : 30000;
            setMeterPollingInterval(intervalMs);
        }

        function startSessionPolling() {
            // ƒ∞lk g√ºncelleme
            updateSessionInfo();
            // 5 saniye aralƒ±kla session bilgisi
            if (sessionUpdateInterval) {
                clearInterval(sessionUpdateInterval);
            }
            sessionUpdateInterval = setInterval(updateSessionInfo, 5000);
        }

        async function updateMeterValues() {
            if (meterPollInProgress) return;
            meterPollInProgress = true;

            try {
                const response = await fetch(`${API_BASE_URL}/api/meter/reading`);
                if (!response.ok) {
                    throw new Error(`HTTP ${response.status}`);
                }

                const result = await response.json();
                const now = new Date();
                const timeStr = now.toLocaleTimeString('en-US');

                if (result && result.success && result.data) {
                    meterErrorCount = 0;
                    document.getElementById('meterDot').classList.remove('offline');

                    const voltage = result.data.voltage_v;
                    const current = result.data.current_a;
                    const powerKw = result.data.power_kw;
                    const energyKwh = result.data.energy_kwh;
                    const powerFactor = result.data.power_factor;
                    const frequency = result.data.frequency_hz;
                    const phaseValuesRaw = result.data.phase_values || {};
                    const totalsRaw = result.data.totals || {};

                    // If phase values missing, fall back to totals to avoid empty UI
                    const safe = (val, fallback) =>
                        val === null || val === undefined ? fallback : val;

                    const pvV = phaseValuesRaw.voltage_v || {};
                    const pvI = phaseValuesRaw.current_a || {};
                    const pvP = phaseValuesRaw.power_kw || {};

                    const phaseValues = {
                        voltage_v: {
                            l1: safe(pvV.l1, voltage),
                            l2: safe(pvV.l2, voltage),
                            l3: safe(pvV.l3, voltage),
                        },
                        current_a: {
                            l1: safe(pvI.l1, current),
                            l2: safe(pvI.l2, current),
                            l3: safe(pvI.l3, current),
                        },
                        power_kw: {
                            l1: safe(pvP.l1, powerKw),
                            l2: safe(pvP.l2, powerKw),
                            l3: safe(pvP.l3, powerKw),
                        },
                    };

                    const swapPhaseOrder = (phaseObj = {}) => ({
                        l1: safe(phaseObj.l3, phaseObj.l1),
                        l2: safe(phaseObj.l2, phaseObj.l2),
                        l3: safe(phaseObj.l1, phaseObj.l3),
                    });

                    phaseValues.voltage_v = swapPhaseOrder(phaseValues.voltage_v);
                    phaseValues.current_a = swapPhaseOrder(phaseValues.current_a);
                    phaseValues.power_w = swapPhaseOrder(phaseValues.power_w);
                    phaseValues.power_kw = swapPhaseOrder(phaseValues.power_kw);

                    const totals = {
                        power_kw: safe(totalsRaw.power_kw, powerKw),
                        energy_kwh: safe(totalsRaw.energy_kwh, energyKwh),
                        energy_import_kwh: safe(totalsRaw.energy_import_kwh, null),
                        energy_export_kwh: safe(totalsRaw.energy_export_kwh, null),
                    };

                    updateMeterItem(
                        'meterVoltageValue',
                        voltage,
                        formatMeterNumber(voltage, 0),
                        'meterVoltage'
                    );
                    updateMeterItem(
                        'meterCurrentValue',
                        current,
                        formatMeterNumber(current, 2),
                        'meterCurrent'
                    );
                    // 3-faz toplam g√ºc√º hesapla (API toplamƒ± bazƒ± kurulumlarda tek-faz gibi gelebiliyor)
                    const computedTotalPowerKw = (() => {
                        const v = phaseValuesRaw.voltage_v || {};
                        const i = phaseValuesRaw.current_a || {};
                        const pfSafe = powerFactor !== null && powerFactor !== undefined && !isNaN(Number(powerFactor)) ?
                            Number(powerFactor) :
                            1;

                        const hasAllVI = ['l1', 'l2', 'l3'].every(
                            k => typeof v[k] === 'number' && typeof i[k] === 'number'
                        );
                        if (!hasAllVI) {
                            return totals.power_kw;
                        }

                        const sumKw = (v.l1 * i.l1 + v.l2 * i.l2 + v.l3 * i.l3) / 1000;
                        const sign = powerKw < -0.001 ? -1 : 1;
                        return sign * Math.abs(sumKw * pfSafe);
                    })();

                    const powerDir = computedTotalPowerKw < -0.001 ? 'export' : 'import';
                    const powerDisplay = `${formatMeterNumber(Math.abs(computedTotalPowerKw), 3)} (${powerDir})`;

                    updateMeterItem(
                        'meterPowerValue',
                        computedTotalPowerKw,
                        powerDisplay,
                        'meterPower'
                    );
                    updateMeterItem(
                        'meterEnergyValue',
                        energyKwh,
                        formatMeterNumber(energyKwh, 2),
                        'meterEnergy'
                    );
                    updateMeterItem(
                        'meterPFValue',
                        powerFactor,
                        powerFactor !== null && powerFactor !== undefined ?
                        powerFactor.toFixed(3) :
                        '-',
                        'meterPF'
                    );
                    updateMeterItem(
                        'meterFreqValue',
                        frequency,
                        frequency !== null && frequency !== undefined ?
                        frequency.toFixed(2) :
                        '-',
                        'meterFreq'
                    );

                    // Faz detaylarƒ±
                    const fmt = (v, d = 2) =>
                        v !== null && v !== undefined ? v.toFixed(d) : '-';

                    document.getElementById('meterPhaseVoltage').textContent =
                        `L1: ${fmt(phaseValues.voltage_v.l1, 0)}, L2: ${fmt(phaseValues.voltage_v.l2, 0)}, L3: ${fmt(phaseValues.voltage_v.l3, 0)}`;
                    document.getElementById('meterPhaseCurrent').textContent =
                        `L1: ${fmt(phaseValues.current_a.l1, 2)}, L2: ${fmt(phaseValues.current_a.l2, 2)}, L3: ${fmt(phaseValues.current_a.l3, 2)}`;
                    document.getElementById('meterPhasePower').textContent =
                        `L1: ${fmt(phaseValues.power_kw.l1, 3)}, L2: ${fmt(phaseValues.power_kw.l2, 3)}, L3: ${fmt(phaseValues.power_kw.l3, 3)}`;

                    const totalPower = computedTotalPowerKw;
                    const totalEnergy = totals.energy_kwh;
                    const totalDir = totalPower !== null && totalPower !== undefined && totalPower < -0.001 ? 'export' : 'import';
                    document.getElementById('meterTotals').textContent =
                        `P: ${fmt(Math.abs(totalPower || 0), 3)} kW (${totalDir}), E: ${fmt(totalEnergy, 2)} kWh`;

                    // Meter enerji baseline'ƒ±nƒ± g√ºncelle
                    lastMeterEnergyKwh = energyKwh;
                    lastMeterData.power_kw = computedTotalPowerKw;
                    lastMeterData.energy_kwh = energyKwh;
                    lastMeterData.total_power_dir = totalDir;

                    // G√º√ß y√∂n√º uyarƒ±sƒ± (STATE=CHARGING ve export ise)
                    const isCharging = window.lastStatusState === 5;
                    const isExport = computedTotalPowerKw < -0.1;
                    setMetricState('meterPower', isExport && isCharging ? 'warning' : 'normal');
                    setMetricState('meterEnergy', 'normal');

                    document.getElementById('meterLastUpdate').textContent = `Meter: ${timeStr}`;
                } else {
                    meterErrorCount += 1;
                    document.getElementById('meterDot').classList.add('offline');

                    if (meterErrorCount >= 3) {
                        clearMeterValues();
                        document.getElementById('meterLastUpdate').textContent =
                            'Meter: offline - data cleared';
                    } else {
                        document.getElementById('meterLastUpdate').textContent =
                            `Meter: offline (${meterErrorCount}/3)`;
                    }
                }
            } catch (error) {
                console.error('Meter update error:', error);
                meterErrorCount += 1;
                document.getElementById('meterDot').classList.add('offline');
                if (meterErrorCount >= 3) {
                    clearMeterValues();
                    document.getElementById('meterLastUpdate').textContent =
                        'Meter: read error - data cleared';
                } else {
                    document.getElementById('meterLastUpdate').textContent =
                        `Meter: read error (${meterErrorCount}/3)`;
                }
            } finally {
                meterPollInProgress = false;
            }
        }

        async function updateSessionInfo() {
            try {
                const resp = await fetch(`${API_BASE_URL}/api/sessions/current`);
                if (!resp.ok) throw new Error(`HTTP ${resp.status}`);
                const result = await resp.json();

                const infoEl = document.getElementById('sessionInfo');
                const powerEl = document.getElementById('sessionPower');
                const energyEl = document.getElementById('sessionEnergy');
                const statusEl = document.getElementById('sessionStatus');

                if (result && result.success && result.session) {
                    const s = result.session;
                    const sessionId = s.session_id || '-';
                    const startTime = s.start_time || null;
                    const status = (s.status || 'UNKNOWN').toUpperCase();
                    const meta = s.metadata || {};
                    const userId = meta.user_id || '-';
                    const startEnergy =
                        meta.start_energy_kwh !== null && meta.start_energy_kwh !== undefined ?
                        meta.start_energy_kwh :
                        (meta.start_energy !== null && meta.start_energy !== undefined ?
                            meta.start_energy :
                            null);
                    const durationSec = s.duration_seconds || (startTime ? Math.max(0, (Date.now() - new Date(startTime).getTime()) / 1000) : 0);

                    // Show only if ACTIVE; otherwise clear
                    const isActive = status === 'ACTIVE';
                    if (!isActive) {
                        infoEl.textContent = 'No active session';
                        statusEl.textContent = '';
                        powerEl.textContent = '';
                        energyEl.textContent = '';
                        currentSessionId = null;
                        sessionEnergyBaselineKwh = null;
                        return;
                    }

                    // Session deƒüi≈ütiyse enerji baseline'ƒ± belirle
                    if (currentSessionId !== sessionId) {
                        currentSessionId = sessionId;
                        sessionEnergyBaselineKwh = startEnergy !== null ? startEnergy : lastMeterEnergyKwh;
                    }

                    const durationText = formatDuration(durationSec);
                    const powerKw = lastMeterData.power_kw !== undefined ? lastMeterData.power_kw : null;
                    const currentEnergy =
                        lastMeterEnergyKwh !== null && lastMeterEnergyKwh !== undefined ?
                        lastMeterEnergyKwh :
                        (lastMeterData.energy_kwh !== null && lastMeterData.energy_kwh !== undefined ?
                            lastMeterData.energy_kwh :
                            null);
                    if (sessionEnergyBaselineKwh === null && startEnergy !== null) {
                        sessionEnergyBaselineKwh = startEnergy;
                    }
                    let energyDelta = null;
                    if (currentEnergy !== null && sessionEnergyBaselineKwh !== null && currentEnergy >= sessionEnergyBaselineKwh) {
                        energyDelta = currentEnergy - sessionEnergyBaselineKwh;
                    }

                    infoEl.textContent = sessionId;
                    statusEl.textContent = `${status} | Duration: ${durationText}${userId !== '-' ? ` | User: ${userId}` : ''}`;
                    powerEl.textContent = powerKw !== null ? `${Math.abs(powerKw).toFixed(3)} kW` : '-';
                    energyEl.textContent =
                        energyDelta !== null ? `${energyDelta.toFixed(3)} kWh` : '-';
                } else {
                    document.getElementById('sessionInfo').textContent = 'No active session';
                    document.getElementById('sessionStatus').textContent = '';
                    document.getElementById('sessionPower').textContent = '-';
                    document.getElementById('sessionEnergy').textContent = '-';
                    currentSessionId = null;
                    sessionEnergyBaselineKwh = null;
                }
            } catch (error) {
                console.error('Session info error:', error);
            }
        }

        async function startMobileSnapshotPolling() {
            await updateMobileSnapshot();
            if (mobileSnapshotInterval) {
                clearInterval(mobileSnapshotInterval);
            }
            mobileSnapshotInterval = setInterval(updateMobileSnapshot, 7000);
        }

        async function updateMobileSnapshot() {
            const bar = document.getElementById('mobileBar');
            if (!bar) return;
            try {
                const apiKey = cachedApiKey || await getApiKey();
                const headers = apiKey ? {
                    'X-API-Key': apiKey
                } : {};
                const response = await fetch(`${API_BASE_URL}/api/mobile/charging/current`, {
                    headers
                });
                if (!response.ok) throw new Error(`HTTP ${response.status}`);
                const result = await response.json();
                if (!result.success || !result.data) throw new Error('Invalid response');

                const data = result.data;
                const device = data.device || {};
                const session = data.session || null;
                const measurements = data.measurements || {};
                const trend = data.trend || {};
                const alerts = Array.isArray(data.alerts) ? data.alerts : [];

                let availabilityText = 'Offline';
                let stateClass = 'fault';

                if (device && device.connected) {
                    availabilityText = 'Connected';
                    stateClass = 'available';
                }
                if (session && session.status) {
                    const status = session.status.toUpperCase();
                    availabilityText = status;
                    if (status.includes('CHARG')) {
                        stateClass = 'busy';
                    }
                }
                if (device && device.available === false) {
                    stateClass = 'fault';
                    availabilityText = 'Unavailable';
                }

                setMobileBarState(stateClass);
                setMobileValue('mobileAvailability', availabilityText);

                const sessionSummary = session && session.session_id ?
                    `${session.status || 'UNKNOWN'} ‚Ä¢ ${session.session_id}` :
                    'No active session';
                setMobileValue('mobileSessionSummary', sessionSummary);

                const isValidNumber = (val) =>
                    val !== null && val !== undefined && !isNaN(Number(val));

                // Mobile payload'daki total power bazƒ± kurulumlarda tek-faz gibi gelebiliyor.
                // Bu y√ºzden m√ºmk√ºnse 3-faz V/I √ºzerinden total power'ƒ± t√ºret.
                const derivedMobileTotalPowerKw = (() => {
                    const v = measurements.voltage_v || {};
                    const i = measurements.current_a || {};

                    const hasAllVI = ['L1', 'L2', 'L3'].every(
                        k => isValidNumber(v[k]) && isValidNumber(i[k])
                    );
                    if (hasAllVI) {
                        return (Number(v.L1) * Number(i.L1) + Number(v.L2) * Number(i.L2) + Number(v.L3) * Number(i.L3)) / 1000;
                    }

                    const p = measurements.power_kw || {};
                    if (isValidNumber(p.L1) || isValidNumber(p.L2) || isValidNumber(p.L3)) {
                        const l1 = isValidNumber(p.L1) ? Number(p.L1) : 0;
                        const l2 = isValidNumber(p.L2) ? Number(p.L2) : 0;
                        const l3 = isValidNumber(p.L3) ? Number(p.L3) : (isValidNumber(p.total) ? Number(p.total) : 0);
                        const sum = l1 + l2 + l3;
                        return sum > 0 ? sum : null;
                    }

                    return null;
                })();

                const realtimePower =
                    isValidNumber(derivedMobileTotalPowerKw) ? derivedMobileTotalPowerKw :
                    (measurements.power_kw && isValidNumber(measurements.power_kw.total)) ? measurements.power_kw.total :
                    (typeof data.realtime_power_kw === 'number' ? data.realtime_power_kw :
                        (session && isValidNumber(session.power_kw_current) ? session.power_kw_current : null));
                setMobileValue('mobileRealtimePower', formatNumberWithUnit(realtimePower, 'kW', 2));

                // session.energy_kwh null gelebiliyor; null ise measurements.energy_kwh.import'a fallback yap
                const energyDelivered =
                    (session && isValidNumber(session.energy_kwh)) ?
                    session.energy_kwh :
                    (measurements.energy_kwh && isValidNumber(measurements.energy_kwh.import)) ?
                    measurements.energy_kwh.import :
                    null;
                setMobileValue('mobileEnergyDelivered', formatNumberWithUnit(energyDelivered, 'kWh', 3));

                const cost = session && session.cost ? session.cost : null;
                const currency = (cost && cost.currency) || (device && device.currency) || 'TRY';
                let costText = '-';
                if (cost) {
                    if (cost.estimated_total !== null && cost.estimated_total !== undefined) {
                        costText = formatCurrencyDisplay(cost.estimated_total, currency);
                    } else if (cost.per_kwh !== null && cost.per_kwh !== undefined) {
                        costText = `${formatCurrencyDisplay(cost.per_kwh, currency)} /kWh`;
                    }
                }
                setMobileValue('mobileCostEstimate', costText);

                let trendText = '-';
                if (trend && (trend.energy_kwh_today !== undefined || trend.sessions_today !== undefined)) {
                    const energyToday = trend.energy_kwh_today !== undefined ? `${Number(trend.energy_kwh_today).toFixed(2)} kWh` : null;
                    const sessionsToday = trend.sessions_today !== undefined ? `${trend.sessions_today} session` : null;
                    trendText = [energyToday, sessionsToday].filter(Boolean).join(' | ') || '-';
                }
                setMobileValue('mobileTrendEnergy', trendText);

                setMobileValue('mobileAlertCount', `${alerts.length} active`);
                setMobileValue('mobileSnapshotUpdate', `Mobile snapshot: ${formatDateLabel(data.timestamp)}`);
            } catch (error) {
                console.error('Mobile snapshot error:', error);
                setMobileSnapshotOffline();
            }
        }

        function setMobileSnapshotOffline() {
            setMobileBarState('fault');
            ['mobileAvailability', 'mobileSessionSummary', 'mobileRealtimePower', 'mobileEnergyDelivered', 'mobileCostEstimate', 'mobileTrendEnergy', 'mobileAlertCount']
            .forEach(id => setMobileValue(id, '-'));
            setMobileValue('mobileSnapshotUpdate', 'Mobile snapshot: connection error');
        }

        function formatDuration(seconds) {
            if (!seconds || seconds < 1) return '0 s';
            const hrs = Math.floor(seconds / 3600);
            const mins = Math.floor((seconds % 3600) / 60);
            const secs = Math.floor(seconds % 60);
            const parts = [];
            if (hrs) parts.push(`${hrs} h`);
            if (mins) parts.push(`${mins} min`);
            if (secs || parts.length === 0) parts.push(`${secs} s`);
            return parts.join(' ');
        }

        function setMobileBarState(state) {
            const bar = document.getElementById('mobileBar');
            if (!bar) return;
            bar.classList.remove('mobile-available', 'mobile-busy', 'mobile-fault');
            if (state === 'busy') {
                bar.classList.add('mobile-busy');
            } else if (state === 'fault') {
                bar.classList.add('mobile-fault');
            } else {
                bar.classList.add('mobile-available');
            }
        }

        function setMobileValue(elementId, value) {
            const el = document.getElementById(elementId);
            if (el) {
                el.textContent = value;
            }
        }

        function formatNumberWithUnit(value, unit = '', digits = 2) {
            if (value === null || value === undefined || isNaN(Number(value))) return '-';
            const formatted = Number(value).toFixed(digits);
            return unit ? `${formatted} ${unit}` : formatted;
        }

        function formatCurrencyDisplay(value, currency = 'TRY') {
            if (value === null || value === undefined || isNaN(Number(value))) return '-';
            try {
                return new Intl.NumberFormat('tr-TR', {
                    style: 'currency',
                    currency
                }).format(Number(value));
            } catch (error) {
                return `${Number(value).toFixed(2)} ${currency}`;
            }
        }

        function formatDateLabel(value) {
            if (!value) return '-';
            try {
                const date = new Date(value);
                if (isNaN(date.getTime())) return value;
                return date.toLocaleString('tr-TR');
            } catch (error) {
                return value;
            }
        }

        // Sayfa kapatƒ±lƒ±rken polling'i durdur
        window.addEventListener('beforeunload', () => {
            if (statusUpdateInterval) {
                clearInterval(statusUpdateInterval);
            }
            if (systemMetricsInterval) {
                clearInterval(systemMetricsInterval);
            }
            if (meterUpdateInterval) {
                clearInterval(meterUpdateInterval);
            }
            if (sessionUpdateInterval) {
                clearInterval(sessionUpdateInterval);
            }
            if (mobileSnapshotInterval) {
                clearInterval(mobileSnapshotInterval);
            }
        });

        function updateCurlPreviewDebounced(method, path, bodyElementId, curlElementId, isNumber = false) {
            /**
             * Debounced curl preview update - Performans optimizasyonu
             * Input deƒüi≈üikliklerinde 300ms bekle, sonra g√ºncelle
             */
            const key = `${method}-${path}`;
            if (curlPreviewTimeouts[key]) {
                clearTimeout(curlPreviewTimeouts[key]);
            }
            curlPreviewTimeouts[key] = setTimeout(() => {
                updateCurlPreview(method, path, bodyElementId, curlElementId, isNumber);
            }, 300);
        }

        async function updateCurlPreview(method, path, bodyElementId, curlElementId, isNumber = false) {
            const curlElement = document.getElementById(curlElementId);
            if (!curlElement) return;

            // Get API key
            if (!cachedApiKey) {
                cachedApiKey = await getApiKey();
            }

            // Prepare request body
            let requestBody = null;
            let requestBodyDisplay = null;

            if (bodyElementId) {
                const bodyElement = document.getElementById(bodyElementId);
                if (isNumber) {
                    // For number input (maxcurrent)
                    const value = parseInt(bodyElement.value);
                    // Validate amperage
                    if (isNaN(value) || value < 6 || value > 32) {
                        curlElement.value = `# Invalid amperage: ${bodyElement.value}. Must be between 6 and 32.`;
                        return;
                    }
                    requestBody = {
                        amperage: value
                    };
                    requestBodyDisplay = JSON.stringify(requestBody, null, 2);
                } else {
                    // For textarea (JSON)
                    const text = bodyElement.value.trim();
                    if (text) {
                        try {
                            requestBody = JSON.parse(text);
                            requestBodyDisplay = JSON.stringify(requestBody, null, 2);
                        } catch (e) {
                            // Invalid JSON, use raw text
                            requestBodyDisplay = text;
                        }
                    } else {
                        requestBody = {};
                        requestBodyDisplay = '{}';
                    }
                }
            } else {
                requestBodyDisplay = 'null';
            }

            // Generate curl command
            const curlCommand = generateCurlCommand(method, path, cachedApiKey, requestBodyDisplay);
            curlElement.value = curlCommand;
        }

        async function testEndpoint(method, path, bodyElementId, isNumber = false, event = null, responseOverrideId = null) {
            const responseSection = document.getElementById(responseOverrideId || `response-${path}`);
            // Button'u bul - √∂nce event'ten, sonra ID'den, sonra onclick handler'dan
            let button = null;
            if (event && event.target) {
                button = event.target;
            } else if (window.event && window.event.target) {
                button = window.event.target;
            } else {
                // √ñzel ID'lerden button'u bul
                if (path === '/api/maxcurrent') {
                    button = document.getElementById('btn-maxcurrent');
                }
                if (!button) {
                    // onclick handler'dan button'u bul
                    button = document.querySelector(`button[onclick*="${path}"]`);
                }
                if (!button) {
                    // Son √ßare: response section'a en yakƒ±n button'u bul
                    const parent = responseSection ? responseSection.closest('.endpoint') : null;
                    button = parent ? parent.querySelector('button.btn') : null;
                }
            }
            if (!button) {
                console.error(`Button not found for path: ${path}`);
                alert(`Button bulunamadƒ±: ${path}`);
                return;
            }
            const originalText = button.textContent;

            // Loading state
            button.disabled = true;
            button.innerHTML = originalText + '<span class="loading"></span>';

            // Hide previous response
            responseSection.classList.remove('show');

            try {
                // Prepare request body
                let requestBody = null;
                let requestBodyDisplay = null;

                if (bodyElementId) {
                    const bodyElement = document.getElementById(bodyElementId);
                    if (isNumber) {
                        // For number input (maxcurrent)
                        const value = parseInt(bodyElement.value);
                        requestBody = {
                            amperage: value
                        };
                        requestBodyDisplay = JSON.stringify(requestBody, null, 2);
                    } else {
                        // For textarea (JSON)
                        const text = bodyElement.value.trim();
                        if (text) {
                            try {
                                requestBody = JSON.parse(text);
                                requestBodyDisplay = JSON.stringify(requestBody, null, 2);
                            } catch (e) {
                                throw new Error(`Invalid JSON: ${e.message}`);
                            }
                        } else {
                            requestBody = {};
                            requestBodyDisplay = '{}';
                        }
                    }
                } else {
                    requestBodyDisplay = 'null';
                }

                // Prepare request options
                const options = {
                    method: method,
                    headers: {
                        'Content-Type': 'application/json',
                        'X-API-Key': await getApiKey() // Get API key from backend
                    }
                };

                if (requestBody) {
                    options.body = JSON.stringify(requestBody);
                }

                // Make request
                const startTime = Date.now();
                const response = await fetch(`${API_BASE_URL}${path}`, options);
                const endTime = Date.now();
                const responseTime = endTime - startTime;

                // Get response body
                const responseText = await response.text();
                let responseBody;
                try {
                    responseBody = JSON.parse(responseText);
                } catch (e) {
                    responseBody = responseText;
                }

                // Get API key for display
                const apiKey = await getApiKey();

                // Display response
                displayResponse(responseSection, {
                    method,
                    path,
                    requestBody: requestBodyDisplay,
                    apiKey: apiKey,
                    status: response.status,
                    statusText: response.statusText,
                    responseTime,
                    responseBody: typeof responseBody === 'string' ? responseBody : JSON.stringify(responseBody, null, 2)
                });

            } catch (error) {
                // Get API key for display
                const apiKey = await getApiKey();

                // User-friendly error messages
                let errorMessage = error.message || 'Unknown error occurred';
                let userFriendlyMessage = errorMessage;

                if (errorMessage.includes('Failed to fetch') || errorMessage.includes('NetworkError')) {
                    userFriendlyMessage = 'Network error: Could not connect to API server. Please check if the server is running.';
                } else if (errorMessage.includes('Invalid JSON')) {
                    userFriendlyMessage = `Invalid JSON format: ${errorMessage}`;
                } else if (errorMessage.includes('Invalid amperage')) {
                    userFriendlyMessage = errorMessage;
                }

                // Display error
                displayResponse(responseSection, {
                    method,
                    path,
                    requestBody: requestBodyDisplay || 'null',
                    apiKey: apiKey,
                    status: 'ERROR',
                    statusText: userFriendlyMessage,
                    responseTime: null,
                    responseBody: error.toString()
                });
            } finally {
                button.disabled = false;
                button.innerHTML = originalText;
            }
        }

        async function getApiKey() {
            try {
                // Get API key from backend endpoint
                const response = await fetch(`${API_BASE_URL}/api/test/key`);
                const data = await response.json();
                return data.api_key || '';
            } catch (error) {
                console.error('Failed to get API key:', error);
                return '';
            }
        }

        function escapeShellString(str) {
            /**
             * Shell komutlarƒ± i√ßin g√ºvenli string escape fonksiyonu
             * T√ºm shell √∂zel karakterlerini escape eder
             */
            if (typeof str !== 'string') return '';
            return str
                .replace(/\\/g, '\\\\') // Backslash'i √∂nce escape et
                .replace(/'/g, "'\\''") // Single quote escape
                .replace(/[;&|`$(){}[\]<>]/g, '\\$&') // Diƒüer shell √∂zel karakterler
                .replace(/\n/g, '\\n') // Newline
                .replace(/\r/g, '\\r') // Carriage return
                .replace(/\t/g, '\\t'); // Tab
        }

        function generateCurlCommand(method, path, apiKey, requestBody) {
            const url = `${API_BASE_URL}${path}`;
            let curlCmd = `curl -X ${method} "${url}"`;

            // Add headers
            curlCmd += ` \\\n  -H "Content-Type: application/json"`;
            curlCmd += ` \\\n  -H "X-API-Key: ${escapeShellString(apiKey)}"`;

            // Add body if exists
            if (requestBody && requestBody !== 'null' && requestBody.trim() !== '') {
                const bodyStr = typeof requestBody === 'string' ? requestBody : JSON.stringify(requestBody);
                // G√ºvenli shell escape
                const escapedBody = escapeShellString(bodyStr);
                curlCmd += ` \\\n  -d '${escapedBody}'`;
            }

            return curlCmd;
        }

        function replacePathParams(path, paramValue) {
            /**
             * Path parametrelerini deƒüerlerle deƒüi≈ütir
             * √ñrnek: /api/sessions/{session_id} -> /api/sessions/123
             */
            if (!paramValue || paramValue.trim() === '') {
                return path;
            }
            return path.replace(/\{[^}]+\}/g, paramValue.trim());
        }

        async function updateCurlPreviewForPathParam(method, pathTemplate, paramElementId, curlElementId) {
            /**
             * Path parametreli endpoint'ler i√ßin curl preview g√ºncelle
             */
            const curlElement = document.getElementById(curlElementId);
            if (!curlElement) return;

            // Get API key
            if (!cachedApiKey) {
                cachedApiKey = await getApiKey();
            }

            // Get parameter value
            const paramElement = document.getElementById(paramElementId);
            const paramValue = paramElement ? paramElement.value.trim() : '';

            // Replace path parameters
            const actualPath = replacePathParams(pathTemplate, paramValue);

            // Generate curl command
            const curlCommand = generateCurlCommand(method, actualPath, cachedApiKey, null);
            curlElement.value = curlCommand;
        }

        async function testEndpointWithPathParam(method, pathTemplate, paramElementId) {
            /**
             * Path parametreli endpoint'ler i√ßin test fonksiyonu
             */
            const paramElement = document.getElementById(paramElementId);
            const paramValue = paramElement ? paramElement.value.trim() : '';

            if (!paramValue) {
                alert('L√ºtfen parametre deƒüerini girin!');
                return;
            }

            // Replace path parameters
            const actualPath = replacePathParams(pathTemplate, paramValue);

            // Response section ID (use template path for consistency)
            const responseSection = document.getElementById(`response-${pathTemplate}`);
            const button = event.target;
            const originalText = button.textContent;

            // Loading state
            button.disabled = true;
            button.innerHTML = originalText + '<span class="loading"></span>';

            // Hide previous response
            responseSection.classList.remove('show');

            try {
                // Prepare request options
                const options = {
                    method: method,
                    headers: {
                        'Content-Type': 'application/json',
                        'X-API-Key': await getApiKey()
                    }
                };

                // Make request
                const startTime = Date.now();
                const response = await fetch(`${API_BASE_URL}${actualPath}`, options);
                const endTime = Date.now();
                const responseTime = endTime - startTime;

                // Get response body
                const responseText = await response.text();
                let responseBody;
                try {
                    responseBody = JSON.parse(responseText);
                } catch (e) {
                    responseBody = responseText;
                }

                // Get API key for display
                const apiKey = await getApiKey();

                // Display response
                displayResponse(responseSection, {
                    method,
                    path: actualPath,
                    requestBody: 'null',
                    apiKey: apiKey,
                    status: response.status,
                    statusText: response.statusText,
                    responseTime,
                    responseBody: typeof responseBody === 'string' ? responseBody : JSON.stringify(responseBody, null, 2)
                });

            } catch (error) {
                // Get API key for display
                const apiKey = await getApiKey();

                // User-friendly error messages
                let errorMessage = error.message || 'Unknown error occurred';
                let userFriendlyMessage = errorMessage;

                if (errorMessage.includes('Failed to fetch') || errorMessage.includes('NetworkError')) {
                    userFriendlyMessage = 'Network error: Could not connect to API server. Please check if the server is running.';
                }

                // Display error
                displayResponse(responseSection, {
                    method,
                    path: actualPath,
                    requestBody: 'null',
                    apiKey: apiKey,
                    status: 'ERROR',
                    statusText: userFriendlyMessage,
                    responseTime: null,
                    responseBody: error.toString()
                });
            } finally {
                button.disabled = false;
                button.innerHTML = originalText;
            }
        }

        function buildMobileSessionsPath() {
            const params = new URLSearchParams();
            const limitInput = document.getElementById('mobileSessionsLimit');
            const statusSelect = document.getElementById('mobileSessionsStatus');
            const userInput = document.getElementById('mobileSessionsUserId');
            const fromInput = document.getElementById('mobileSessionsFrom');
            const toInput = document.getElementById('mobileSessionsTo');

            if (limitInput && limitInput.value) {
                params.set('limit', limitInput.value);
            }
            if (statusSelect && statusSelect.value) {
                params.set('status', statusSelect.value);
            }
            if (userInput && userInput.value.trim()) {
                params.set('user_id', userInput.value.trim());
            }
            if (fromInput && fromInput.value) {
                params.set('from', formatDateInputValue(fromInput.value));
            }
            if (toInput && toInput.value) {
                params.set('to', formatDateInputValue(toInput.value));
            }

            const query = params.toString();
            return `/api/mobile/charging/sessions${query ? `?${query}` : ''}`;
        }

        function formatDateInputValue(value) {
            if (!value) return '';
            try {
                const date = new Date(value);
                if (isNaN(date.getTime())) {
                    return value;
                }
                return date.toISOString();
            } catch (error) {
                return value;
            }
        }

        function updateMobileSessionsCurl() {
            const path = buildMobileSessionsPath();
            updateCurlPreview('GET', path, null, 'curl-/api/mobile/charging/sessions');
        }

        async function testMobileSessionsList(event) {
            const path = buildMobileSessionsPath();
            await testEndpoint('GET', path, null, false, event, 'response-/api/mobile/charging/sessions');
        }

        async function displayResponse(section, data) {
            const statusClass = data.status >= 200 && data.status < 300 ? 'success' :
                data.status === 'ERROR' ? 'error' : 'info';

            // Use provided API key or get it
            const apiKey = data.apiKey || await getApiKey();
            const curlCommand = generateCurlCommand(data.method, data.path, apiKey, data.requestBody);

            section.innerHTML = `
                <div class="response-header">
                    <h3>Response</h3>
                    <div>
                        <span class="status-badge ${statusClass}">${data.status} ${data.statusText || ''}</span>
                        ${data.responseTime ? `<span style="margin-left: 10px; color: #666; font-size: 0.85em;">${data.responseTime}ms</span>` : ''}
                    </div>
                </div>

                <div class="section-title">üíª cURL Command</div>
                <div class="request-display">${escapeHtml(curlCommand)}</div>

                <div class="section-title">üì§ Request</div>
                <div class="request-display">${escapeHtml(data.method)} ${escapeHtml(data.path)}
${data.requestBody && data.requestBody !== 'null' ? escapeHtml(data.requestBody) : 'No body'}</div>

                <div class="section-title">üì• Response</div>
                <div class="response-display">${escapeHtml(data.responseBody)}</div>
            `;

            section.classList.add('show');
        }

        function escapeHtml(text) {
            const div = document.createElement('div');
            div.textContent = text;
            return div.innerHTML;
        }
    </script>
</body>

</html>